import { p, something, assert } from "base/base.ts"
import { Log } from "base/log.ts"
import { sql, SQL, sqlToString } from "./sql.ts"
import { Db } from "./db.ts"

class DbTable<T> {
  constructor(
    public
    public readonly name: string,
    public readonly ids:  string[],
    public readonly auto_id: boolean
  ) {
    this.log = new Log("DbTable", this.url.name)
  }



proc log[T](table: DbTable[T]): Log = Log.init("db", table.db.id)


# db.table -----------------------------------------------------------------------------------------
proc table*[T](
  db:       Db,
  _:        type[T],
  name:     string,
  ids     = @["id"],
  auto_id = false
): DbTable[T] =
  DbTable[T](db: db, name: name, ids: ids, auto_id: auto_id)


# o.column_names -----------------------------------------------------------------------------------
proc column_names*[T](o: T): seq[string] =
  when compiles(o.custom_column_names): o.custom_column_names
  else:                                 o.field_names

# table.create -------------------------------------------------------------------------------------
proc create*[T](table: DbTable[T], o: var T): void =
  if table.ids.is_empty:
    table.log.with((table: table.name)).info "{table}.create"
    let query = block:
      let column_names = if table.auto_id: o.column_names.filter((n) => n notin table.ids)
      else:                                o.column_names
      let names = " " & column_names.join(",  ")
      let values = column_names.map((n) => fmt":{n}").join(", ")
      fmt"""
        insert into {table.name}
          ({names})
        values
          ({values})
      """.dedent

    # table.db.exec(sql(query, o, false), log = false)
    table.db.exec(sql(query, o, false), log = false)
  else:
    table.log.with((table: table.name)).info "{table}.create"
    let query = block:
      let column_names = if table.auto_id: o.column_names.filter((n) => n notin table.ids)
      else:                                o.column_names
      let names = " " & column_names.join(",  ")
      let values = column_names.map((n) => fmt":{n}").join(", ")
      let ids = table.ids.join(", ")
      fmt"""
        insert into {table.name}
          ({names})
        values
          ({values})
        returning {ids}
      """.dedent

    # table.db.exec(sql(query, o, false), log = false)
    let rows = table.db.get_raw(sql(query, o, false), log = false)

    # updating ids, in case it was auto-generated by database
    if rows.len < 1: throw "didn't get any returning ids from insert"
    if rows.len > 1: throw fmt"got too many returning ids {rows.len} from insert"
    o.update_from rows[0]


# table.update -------------------------------------------------------------------------------------
proc update*[T](table: DbTable[T], o: T): void =
  if table.ids.is_empty: throw "can't update object without id"
  table.log.with((table: table.name, id: o.id)).info "{table}.update id={id}"
  let query = block:
    let setters = o.column_names.filter((n) => n notin table.ids).map((n) => fmt"{n} = :{n}").join(", ")
    let where = table.ids.map((n) => fmt"{n} = :{n}").join(" and ")
    fmt"""
      update {table.name}
      set
        {setters}
      where {where}
    """.dedent
  table.db.exec(sql(query, o), log = false)


# table.save ---------------------------------------------------------------------------------------
proc save_impl*[T](table: DbTable[T], o: T): JsonNode =
  if table.ids.is_empty: throw "can't save object without id"
  table.log.with((table: table.name)).info "{table}.save"
  let query = block:
    let column_names = if table.auto_id: o.column_names.filter((n) => n notin table.ids)
    else:                                o.column_names
    let ids = table.ids.join(", ")
    let insert_columns = " " & column_names.join(",  ")
    let insert_values  = column_names.map((n) => fmt":{n}").join(", ")
    let setters = column_names.map((n) => fmt"{n} = excluded.{n}").join(", ")
    fmt"""
      insert into {table.name}
        ({insert_columns})
      values
        ({insert_values})
      on conflict ({ids}) do update
      set
        {setters}
      returning {ids}
    """.dedent

  # table.db.exec(sql(query(), o, false), log = false)
  let rows = table.db.get_raw(sql(query, o, false), log = false)

  # updating ids, in case it was auto-generated by database
  if rows.len < 1: throw "didn't get any returning ids from save"
  if rows.len > 1: throw fmt"got too many returning ids {rows.len} from save"
  rows[0]

proc is_same_values[T](o: T, partial: JsonNode): bool =
  for k, v in o.field_pairs:
    if k in partial.fields:
      if v != partial.fields[k].json_to(typeof v): return false
  true

proc save*[T](table: DbTable[T], o: T): void =
  let ids = table.save_impl o
  # Ensuring ids are the same
  if not is_same_values(o, ids): throw "ids returned from database is different, save with var shoudl be used"

proc save*[T](table: DbTable[T], o: var T): void =
  # Updates object id, needed when id is auto generated by database
  let ids = table.save_impl o
  o.update_from ids

# build_where --------------------------------------------------------------------------------------
proc build_where[W](where: W): SQL =
  when where is SQL:
    where
  elif where is tuple:
    let conditions = where.field_names.map((name) => fmt"{name} = :{name}").join(" and ")
    sql(conditions, where)
  elif where is string or where is int:
    sql "id = {where}"
  else:
    throw fmt"unsupported where clause {where}"

test "build_query":
  assert build_where(sql"id = {1}") == sql("id = :id", (id: 1))

  assert build_where((id: 1)) == sql("id = :id", (id: 1))

  assert build_where(1) == sql("id = :id", (id: 1))

# table.filter -------------------------------------------------------------------------------------
proc filter*[T, W](table: DbTable[T], where: W = sql"", limit = 0, log = true): seq[T] =
  if log: table.log.with((table: table.name, where: $where)).info "{table}.get {where}"
  let where_query = build_where(where)
  let where_key = if where_query.query == "": "" else: " where "
  let limit_s = if limit > 0: fmt" limit {limit}" else: ""
  var query = fmt"select * from {table.name}{where_key}{where_query.query}{limit_s}"
  table.db.get((query, where_query.values), T, log = false)


# table.get_one -----------------------------------------------------------------------------------
proc fget*[T, W](table: DbTable[T], where: W = sql"", log = true): Option[T] =
  if log: table.log.with((table: table.name, where: $where)).info "{table}.get_one {where}"
  let found = table.filter(where, log = false)
  if found.len > 1: throw fmt"expected one but found {found.len} objects"
  if found.len > 0: found[0].some else: T.none


# table.del ----------------------------------------------------------------------------------------
proc del*[T, W](table: DbTable[T], where: W = sql"", log = true): void =
  # Should be split into two procs when this issue will be fixed https://github.com/nim-lang/Nim/issues/18031
  when where is T:
    if table.ids.is_empty: throw "can't delete object without id"
    let o = where
    table.log.with((table: table.name)).info "{table}.del"
    let where = table.ids.map((n) => fmt"{n} = :{n}").join(" and ")
    let query = fmt"delete from {table.name} where {where}"
    table.db.exec(sql(query, o, validate_unused_keys = false), log = false)
  else:
    if log: table.log.with((table: table.name, where: $where)).info "{table}.del {where}"
    let where_query = build_where(where)
    if where_query.query == "": throw "use del_all to delete whole table"
    var query = fmt"delete from {table.name} where {where_query.query}"
    table.db.exec((query, where_query.values), log = false)


# table.del_all ------------------------------------------------------------------------------------
proc del_all*[T, W: SQL | tuple](table: DbTable[T], where: W = sql"", log = true): seq[T] =
  if log: table.log.with((table: table.name, where: $where)).info "{table}.del_all"
  var query = fmt"delete from {table.name}"
  table.db.exec(sql(query), log = false)


# table.refresh ------------------------------------------------------------------------------------
# Reload from the database
proc refresh*[T](table: DbTable[T], o: T, log = true): T =
  if table.ids.is_empty: throw "can't refresh object without id"
  let where_query = table.ids.map((n) => fmt"{n} = :{n}").join(" and ")
  let where = sql(where_query, o, false)
  if log: table.log.with((table: table.name, where: $where)).info "{table}.refresh {where}"
  table.fget(where, log = false).ensure fmt"can't refresh {where}"


# table.count --------------------------------------------------------------------------------------
proc count*[T, W](table: DbTable[T], where: W = sql""): int =
  table.log.with((table: table.name, where: $where)).info "{table}.count {where}"
  let where_query = build_where(where)
  let where_key = if where_query.query == "": "" else: " where "
  var query = fmt"select count(*) from {table.name}{where_key}{where_query.query}"
  table.db.get_one((query, where_query.values), int, log = false)


# table.contains -----------------------------------------------------------------------------------
proc contains*[T, W](table: DbTable[T], where: W = sql""): bool =
  table.count(where) > 0


# [] -----------------------------------------------------------------------------------------------
proc `[]`*[T, W](table: DbTable[T], where: W): T =
  table.fget(where).get

proc `[]`*[T, W](table: DbTable[T], where: W, default: T): T =
  table.fget(where).get(default)


# Test ---------------------------------------------------------------------------------------------
if is_main_module:
  let db = Db.init
  db.impl("nim_test")

  db.before sql"""
    drop table if exists test_db_table_users;

    create table test_db_table_users(
      id   integer      not null,
      name varchar(100) not null,
      age  integer      not null,

      primary key (id)
    );
  """


  # Defining User Model
  type User = object
    id:   int
    name: string
    age:  int

  let users = db.table(User, "test_db_table_users")

  # Saving
  var jim = User(id: 1, name: "Jim", age: 30)
  users.create jim

  users.save jim

  jim.age = 31
  users.save jim

  # refresh
  assert users.refresh(jim) == jim

  # filter
  assert users.filter(sql"age = {31}") == @[jim]
  assert users.filter((age: 31))       == @[jim]
  assert users.filter(1)               == @[jim]

  # []
  assert users[sql"age = {31}"] == jim
  assert users[(age: 31)]       == jim
  assert users[1]               == jim

  # count, has
  assert users.count((age: 31)) == 1
  assert (age: 31) in users

  # del
  users.del (id: -1) # just checking if it's compile
  users.del jim
  assert users.count == 0

  # Cleaning
  db.exec sql"drop table if exists test_db_table_users"